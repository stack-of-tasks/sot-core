/*
 * Copyright 2010,
 * Fran√ßois Bleibel,
 * Olivier Stasse,
 *
 * CNRS/AIST
 *
 */

#ifndef __SOT_SOT_HH
#define __SOT_SOT_HH

/* --------------------------------------------------------------------- */
/* --- INCLUDE --------------------------------------------------------- */
/* --------------------------------------------------------------------- */

/* Matrix */
#include <dynamic-graph/linear-algebra.h>

/* Classes standards. */
#include <list> /* Classe std::list   */

/* SOT */
#include <dynamic-graph/entity.h>
#include <sot/core/flags.hh>
#include <sot/core/task-abstract.hh>

/* --------------------------------------------------------------------- */
/* --- API ------------------------------------------------------------- */
/* --------------------------------------------------------------------- */

#ifndef SOTSOT_CORE_EXPORT
#if defined(WIN32)
#if defined(sot_EXPORTS)
#define SOTSOT_CORE_EXPORT __declspec(dllexport)
#else
#define SOTSOT_CORE_EXPORT __declspec(dllimport)
#endif
#else
#define SOTSOT_CORE_EXPORT
#endif
#endif

/* --------------------------------------------------------------------- */
/* --- CLASS ----------------------------------------------------------- */
/* --------------------------------------------------------------------- */

namespace dynamicgraph {
namespace sot {

/*! @ingroup stackoftasks
  \brief This class implements the Stack of Task.
  It allows to deal with the priority of the controllers
  through the shell.
*/
class SOTSOT_CORE_EXPORT Sot : public Entity {
public:
  /*! \brief Specify the name of the class entity. */
  static const std::string CLASS_NAME;

public:
  /*! \brief Returns the name of this class. */
  virtual const std::string &getClassName() const { return CLASS_NAME; }

  /*! \brief Defines a type for a list of tasks */
  typedef std::list<TaskAbstract *> StackType;

protected:
  /*! \brief This field is a list of controllers
    managed by the stack of tasks. */
  StackType stack;

  /*! \brief Store the number of joints to be used in the
    command computed by the stack of tasks. */
  unsigned int nbJoints;

  /*! \brief Option to disable the computation of the SVD for the last task
    if this task is a Task with a single FeaturePosture */
  bool enablePostureTaskAcceleration;

  /*! \brief Maximum allowed squared norm of control increment.
    A task whose control increment is above this value is discarded.
    It defaults to \c std::numeric_limits<double>::max().
    \warning This is a security feature and is **not** a good way of adding a
    proper constraint on the control generated by SoT.
    */
  double maxControlIncrementSquaredNorm;

public:
  /*! \brief Threshold to compute the dumped pseudo inverse. */
  static const double INVERSION_THRESHOLD_DEFAULT; // = 1e-4;

  /*   static const double DIRECTIONAL_THRESHOLD_DEFAULT = 1e-2; */
  /*   static const bool USE_CONTI_INVERSE_DEFAULT = false; */

  /*! \brief Number of joints by default. */
  static void taskVectorToMlVector(const VectorMultiBound &taskVector,
                                   Vector &err);

public:
  /*! \brief Default constructor */
  Sot(const std::string &name);
  ~Sot(void) { /* TODO!! */
  }

  /*! \name Methods to handle the stack.
    @{
  */
  virtual const StackType &tasks() const { return stack; }

  /*! \brief Push the task in the stack.
    It has a lowest priority than the previous ones.
    If this is the first task, then it has the highest
    priority. */
  virtual void push(TaskAbstract &task);
  /*! \brief Pop the task from the stack.
    This method removes the task with the smallest
    priority in the task. The other are projected
    in the null-space of their predecessors. */
  virtual TaskAbstract &pop(void);

  /*! \brief This method allows to know if a task exists or not */
  virtual bool exist(const TaskAbstract &task);

  /*! \brief Remove a task regardless to its position in the stack.
    It removes also the signals connected to the output signal of this
    stack.*/
  virtual void remove(const TaskAbstract &task);

  /*! \brief This method removes the output signals depending on
      this task. */
  virtual void removeDependency(const TaskAbstract &key);

  /*! \brief This method makes the task to swap with the task having the
    immediate superior priority. */
  virtual void up(const TaskAbstract &task);

  /*! \brief This method makes the task to swap with the task having the
    immediate inferior priority. */
  virtual void down(const TaskAbstract &task);

  /*! \brief Remove all the tasks from the stack. */
  virtual void clear(void);
  /*! @} */

  /*! @} */

  /*! \brief This method defines the part of the state vector
    which correspond to the free flyer of the robot. */
  virtual void defineNbDof(const unsigned int &nbDof);
  virtual const unsigned int &getNbDof() const { return nbJoints; }

  /*! @} */
public: /* --- CONTROL --- */
  /*! \name Methods to compute the control law following the
    recursive definition of the stack of tasks.
    @{
  */

  /*! \brief Compute the control law. */
  virtual dynamicgraph::Vector &computeControlLaw(dynamicgraph::Vector &control,
                                                  const int &time);

  /*! @} */

public: /* --- DISPLAY --- */
  /*! \name Methods to display the stack of tasks.
    @{
  */
  /*! Display the stack of tasks in text mode as a tree. */
  virtual void display(std::ostream &os) const;
  /*! Wrap the previous method around an operator. */
  SOTSOT_CORE_EXPORT friend std::ostream &operator<<(std::ostream &os,
                                                     const Sot &sot);
  /*! @} */
public: /* --- SIGNALS --- */
  /*! \name Methods to handle signals
    @{
  */
  /*! \brief Intrinsec velocity of the robot, that is used to initialized
   * the recurence of the SOT (e.g. velocity coming from the other
   * OpenHRP plugins).
   */
  SignalPtr<dynamicgraph::Vector, int> q0SIN;
  /*! \brief A matrix K whose columns are a base of the desired velocity.
   * In other words, \f$ \dot{q} = K * u \f$ where \f$ u \f$ is the free
   * parameter to be computed.
   * \note K should be an orthonormal matrix.
   */
  SignalPtr<dynamicgraph::Matrix, int> proj0SIN;
  /*! \brief This signal allow to change the threshold for the
    damped pseudo-inverse on-line */
  SignalPtr<double, int> inversionThresholdSIN;
  /*! \brief Allow to get the result of the computed control law. */
  SignalTimeDependent<dynamicgraph::Vector, int> controlSOUT;
  /*! @} */

  /*! \brief This method write the priority between tasks in the output stream
   * os. */
  virtual std::ostream &writeGraph(std::ostream &os) const;
};
} // namespace sot
} // namespace dynamicgraph

#endif /* #ifndef __SOT_SOT_HH */
